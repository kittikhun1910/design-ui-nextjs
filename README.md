Start
1.Navigate in your terminal where you‚Äôd like to store your project
cd ~/code

2. We‚Äôll follow Reacts how-to guide for spinning up a React app with Next.js
npx create-next-app@latest

3. This will ask you a series of questions ‚Äî name your project and press enter for each of the questions to initialize a basic app


4. Navigate into the application directory and open it in VSCode
cd elana-olson-react-next-app
code . // opens VSCode from terminal

5. Now let‚Äôs serve this baby up and see what we‚Äôre working with! Navigate to the README.md and press ‚áß‚åòV in the editor to preview the markdown.


The README.md tells us to run the development server, type into the terminal
yarn dev

6. Once you see ‚úì Ready in the terminal, navigate to http://localhost:3000 in Chrome and you‚Äôll see something like this:


Congrats! You now have a Next.js React app running!

Understanding the Code
You can read this code in github in the example app: react-portfolio-app

Let‚Äôs investigate the initialized files, Next.js documents the project structure well , but we‚Äôll briefly review what the top level files and folders are for.


.next | Stores features that help with performance like page caching

node_modules | Stores the packages and dependencies defined in package.json

public| Stores publicly accessible files like assets (images)

src | Stores all our custom source code üíö

.eslintrc.json | Configuration for ESLint. ESLint helps us define specific patterns for JavaScript and catch problematic patterns before deploying.

.gitignore | Defines which files/folders not to publish to the repository. Files and folders like node_modules which are far too big to publish or secret files that would expose vulnerable credentials.

next-env.d.ts | TypeScript declaration for Next.js

next.config.mjs | Configuration for Next.js

package.lock.json | Automatically generated by the package manager‚Ä¶ don‚Äôt manually change this file.

package.json | Defines project scripts and dependencies to enable us to run the project

postcss.config.js | Configuration for css

README.md | An engineer‚Äôs ‚ÄúHow To‚Äù guide and crucial documentation for how to use this project

tailwind.config.ts | Configuration for tailwind css

tsconfig.json | Configuration of TypeScript strictness, structure, and compiler

README, package.json, & tsconfig.json
The most important files to review in any project are: README.md , package.json , & tsconfig.json , though all configuration files will impact the structure and strictness of your code.


The scripts section defines what commands we run in the terminal to develop, compile, start, and analyzing code for potential errors. For each of them, type Yarn in front of it to run the script.

Notice that we are on the latest versions of React, React-dom, and Next ‚Äî this is a good practice to follow of staying up to date with all dependencies, but especially the foundational libraries and frameworks.


In the tsconfig.json we want to pay attention to module and moduleResolution ‚Äî these two define how TypeScript scopes global and local state (i.e. Modulaization determines whether a variable in a file is readable and usable outside of that file or package). Using moduleResolution: bundler allows us to define global state via "imports" and "exports" without needing file extensions on relative paths. You can read more here to further understand module theory and how to apply it to your app.

src/
Now that you understand the root level files, take a look into the src/ folder (otherwise known as app). The key files here are layout.tsx and page.tsx ‚Äî Next.js uses pages and layouts to define routes and components in the app.

Pages

In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.

We can think of pages as routes and the pages directory as the root folder/home for all our routes. So if you want to create an About page on your website, it would be accessed at /about and housed in the codebase under pages/about.ts .

Layouts

The React model allows us to deconstruct a page into a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page.

Layouts enable us to create reusable patterns for our app, either for the entire app or per-page.

Next.js details an excellent guide to Page and Layout usage.

Component libraries
A component library is a set of frontend reusable components that are frequently used throughout an application. The library should follow accessibility standards, themes, and enable you to quickly plug and play components into your app so you don‚Äôt have to create entirely new basic components like buttons and menus.

The cons to a library are: you need to familiarize yourself with all the components and there are limitations to what those components will do ‚Äî they will not cover every edge case or design that you have in mind. In cases where you‚Äôre building a very simple app, a component library could be a hindrance, but component libraries can be powerful tools once learned!

Checkout these various UI libraries or incorporate one you are already familiar with! The point of using one is to speed along your coding, so go with something you like.

Material UI (Optional)
Here‚Äôs a short article I wrote detailing how to integrate material ui into a react nextjs app.

Hooks and the Component Lifecycle
Now that we have an army of tools at our command, we need to understand how to wield them‚Ä¶. so the render cycle is of utmost importance! ‚ÄúHooks are functions that let you ‚Äúhook into‚Äù React features like state, lifecycle methods, and context from your function components,‚Äù (The Power of React Hooks).

We can tap into the React render lifecycle in the three phases ‚Äî mount, update, unmount ‚Äî using hooks. The mount phase allows us to insert elements into the DOM, set initial state, and load the elements on the first render. The update phase occurs when props or state changes and we need to update the component, which retriggers the render() function. Finally, the unmount phase removes the react component from the DOM and cleans up any related state.

I suggest reading The Lifecycle of a React Component to understand what React methods are called during these phases. When using hooks, we don‚Äôt call the React functions likegetDerivedStateFromProps()directly, the hooks do this for us. Hooks like useState will initialize, update, and clean state for us as we use the component. The article React Component Lifecycle Methods with React Hooks outlines this relationship and how to transition your use of lifecycle methods to hooks.

The key takeaways here are (1) we need to understand the lifecycle of a React component to know how to update data and (2) hooks help us do this smoothly.

Checkout React‚Äôs docs to thoroughly understand the usage of hooks.
